<!DOCTYPE html>

<html lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us">
<head>
  <link href="screenshare.css" rel="stylesheet" type="text/css" />

  <title>Screen Capture</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c-common"
  type="text/javascript">
//<![CDATA[
  <!-- keep this comment: what a frightening kludge -->
  //]]>
  </script>
  <script class="remove" src="screenshare.js" type="text/javascript">
//<![CDATA[
  <!-- keep this comment -->
  //]]>
  </script>
</head>

<body>
  <section id="abstract">
    <p>This document defines how a user's display, or parts thereof, can be used
    as the source of a video stream using the Media Capture API
    [[!GETUSERMEDIA]].</p>
  </section>


  <section class="informative" id="intro">
    <h2>Introduction</h2>

    <p>This document describes an extension to the Media Capture API
    [[GETUSERMEDIA]] that enables the acquisition of a user's display, or part
    thereof, in the form of a video stream.  This enables a number of
    applications, including screen sharing using WebRTC [[WEBRTC]].</p>

    <p>This feature has signficant security implications.  Applications that use
    this API to access information that is displayed to users could access
    confidential information from other origins if that information is under the
    control of the application.  This includes content that would otherwise be
    inaccessible due to the protections offered by the user agent sandbox.</p>

  </section>


  <section id="conformance">
    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces that it
    contains.</p>


    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification must implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]], as
    this specification uses that specification and terminology.</p>
  </section>


  <section>
    <h2>Terminology</h2>

    <p>Screen capture encompasses the capture of several different types of
    screen-based surfaces.  Collectively, these are referred to as <dfn>display
    surface</dfn>s, of which this document defines the following types:</p>
    <ul>
      <li>A <dfn>screen</dfn> <a>display surface</a> represents a physical
      display. Some systems have multiple <a>screen</a>s, which can be
      identified separately.  Multiple <a>screen</a>s might also be aggregated
      into as a single logical <a>screen</a>.</li>

      <li>A <dfn>window</dfn> <a>display surface</a> is a single contiguous
      surface that is used by a single application.  A single application might
      have several <a>window</a>s available to it, and those can be aggregated
      into a single <dfn>application</dfn> surface, representing all the windows
      available to that application.</li>

      <li>A <dfn>browser</dfn> <a>display surface</a> is the rendered form of a
      single document.  This is not strictly limited to HTML [[HTML5]]
      documents, though the discussion in this document will address some
      specific concerns with the capture of HTML.</li>
    </ul>

    <p>This document draws a distinction between two variants of each type of
    display surface:</p>
    <ul>
      <li>The <dfn>logical display surface</dfn> is the surface that an
      operating system makes available to an application for the purposes of
      rendering.</li>

      <li>The <dfn>visible display surface</dfn> is the portion of a <a>logical
      display surface</a> that is rendered to a <a>screen</a>.</li>
    </ul>

    <p>Some operating systems permit windows from different applications to
    occlude other windows, in whole or part, so the <a>logical display
    surface</a> is a strict subset of the <a>logical display surface</a>.</p>

    <p>This document concerns itself primarily with video, but the general
    mechanisms defined here could be extended to other types of media, of which
    audio [[GETUSERMEDIA]] and depth [[MEDIACAPTURE-DEPTH]] are currently
    defined.</p>
  </section>


  <section>
    <h2>Obtaining Displayed Media</h2>
    <!--
      Interesting Links

      https://bugzilla.mozilla.org/show_bug.cgi?id=742832

      http://www.chromium.org/developers/design-documents/extensions/proposed-changes/apis-under-development/webrtc-tab-content-capture

      https://docs.google.com/document/d/1-vFghorm8zDCeyg2Yk6kKFT-16GU1Ow1b1bor_jCqD8/edit
      -->

    <p>Screen capture is enabled through the addition of a new member to the
    <code>MediaStreamConstraints</code> dictionary that is passed to
    <code>getUserMedia</code> [[!GETUSERMEDIA]].</p>

    <dl class="idl" title="partial dictionary MediaStreamConstraints">
      <dt>MediaSourceType mediaSource = "capture"</dt>
      <dd>
        <p>The <code><a>mediaSource</a></code> member of
        <code>MediaStreamConstraints</code> identifies the type of media source
        that is requested.</p>
      </dd>
    </dl>

    <p>In order to ensure that the applications are able to reliably determine
    whether the <a>user agent</a> supports or is aware of this feature, the
    dictionary response from <code>getSupportedConstraints</code> includes the
    key <code>"mediaSource"</code> if this feature is understood.</p>

    <p>The <code><a>MediaSourceType</a></code> identifies whether media is to be
    sourced from a camera or microphone; or, if the media is to be sourced from
    a screen capture.</p>

    <dl class="idl" title="enum MediaSourceType">
      <dt>capture</dt>

      <dd>The default, a media source type of "capture" indicates that the media
      shall be acquired from a camera, microphone, or other media capture
      device, such as a depth camera [[MEDIACAPTURE-DEPTH]].</dd>

      <dt>display</dt>

      <dd>A media source type of "display" indicates that the media shall be
      acquired from a local display.</dd>
    </dl>

    <section>
      <h2>Selecting a Display Surface</h2>

      <p>Two constraints are defined that allow an application to limit the
      display surfaces that are selected.</p>

      <p>The <code><a
      href="#widl-MediaTrackConstraintSet-screenSurface">screenSurface</a></code>
      constraint allows an application to express a preference or requirement
      for the type of <a>display surface</a> that is acquired.</p>

      <p>The <code><a
      href="#widl-MediaTrackConstraintSet-logicalSurface">logicalSurface</a></code>
      constraint allows an application to express a preference or requirement to
      capture the <a>logical display surface</a>, rather than the <a>visible
      display surface</a>.</p>

      <dl class="idl" title="partial dictionary MediaTrackConstraintSet">
        <dt>ConstrainDOMString screenSurface</dt>

        <dd>
          <p>What type of <a>display surface</a> to capture.  This assumes
          values from the <code><a>ScreenCaptureSurfaceType</a></code>
          enumeration.</p>
        </dd>

        <dt>ConstrainBoolean logicalSurface</dt>

        <dd>
          <p>A value of <code>true</code> requests or requires capture of a
          <a>logical display surface</a>; a value of <code>false</code> requests
          or requires capture of a <a>visible display surface</a>.</p>
        </dd>
      </dl>

      <p>The <code><a>ScreenCaptureSurfaceType</a></code> enumeration describes
      the different types of display surface.</p>

      <dl class="idl" title="enum ScreenCaptureSurfaceType">
        <dt>screen</dt>

        <dd>a <a>screen</a> <a>display surface</a>, physical display, or
        collection of physical displays</dd>

        <dt>window</dt>

        <dd>a <a>window</a> <a>display surface</a>, or single application
        window</dd>

        <dt>application</dt>

        <dd>an <a>application</a> <a>display surface</a>, or entire collection
        of windows for an application</dd>

        <dt>browser</dt>

        <dd>a <a>browser</a> <a>display surface</a>, or single browser window</dd>
      </dl>

      <p class="issue"><a
      href="https://github.com/w3c/mediacapture-screen-share/issues/9">Github#2</a>:
      Determine whether we want to support application capture.</p>

      <section>
        <h2>Logical or Visible Display Surface</h2>

        <p class="issue">The following is old text.</p>

    <p>The video generated MUST be from the portion of the screen belonging to
    the item that was authorized and it MUST be visible. If an application is
    being shared, but the top right corner of the application is covered by a
    window from some other application, that top right corner needs to be
    obscured in the video stream. A typical way to obscure it is by replacing
    the obscured area with a grey rectangle. If an application is shared and
    that application has multiple windows, the video stream to share is formed
    by constructing the bounding box around all the windows in that application
    and sharing a single video stream capturing all the windows in that
    application. Of course any screen area that does not belong to that
    application is obscured.</p>


    <p class="note">Open Issue: Some systems obscure with the image of what was
    visible before it was obscured. Imagine a use caser where Alice is sharing
    a powerpoint presentation with with Bob. Alice gets an instant messages
    which pops up a dialog box on top of th powerpoint application. In some
    systems, the video sent to Bob will show a grey rectangle and Bob will know
    an IM poped up even thought Bob can not see the contents of the IM. In
    other systems, the obscuring will be done using the previously visible
    bitmap so, as long as the powerpoint slide does not change before Alice
    gets rid of the IM dialog box, Bob will not see a big ugly grey rectangle
    in the middle of the slide he is trying to read. The down side is if the
    window being shared was a video, the obscured rectangle will look frozen
    and some users will perceive this as a bug in the system while the grey
    rectangle users will generally understand was an obscured region. There can
    also be cases where as windows in the application are moved around, "old"
    data does not get cleared up as the system is using to generate obscured
    data.</p>


      </section>
    </section>

    <section>
      <h2>User Consent</h2>

    </section>

    <section>
      <h2>Security and Permissions</h2>

      <p>There are significant security concerns with screen capture, which is
      discussed in detail in [[!RTCWEB-SECURITY-ARCH]] and [[!RTCWEB-SECURITY]].
      This section discusses the implications of those security considerations
      and recommends approaches to mitigate those concerns.</p>

      <p>There are several security issues that need to be considered. One of
      the most important is the case of an "evil" web page requesting sharing
      of the browser then the "evil" page managing to open another web page,
      such as a banking page, inside that browser. The "evil" web page could
      then see the information displayed on the banking page. A similar
      mechanism may be usable for bypassing CSRF protection. These attacks and
      others are described in more detail in [[!RTCWEB-SECURITY]]. For this
      reason, this specification only permits sharing of the browser via
      "browser sharing" and requires a heightened permissions experience for
      that use.</p>


      <p>The approach to securing types of sharing where the webpage could
      impact the content that is being shared is to require that web page have
      a persistent permission acquired in some "install" like user experience.
      This allows the "install" user experience to be a place to explain the
      risk to the user. This is referred to as an "Application Permission".
      Some browsers have a concept of an application store and application
      install to support such permissions.</p>


      <p>The approach to sharing where this is not easy for the webpage to
      impact the content is to, each time getUserMedia is called, show the user
      a dialog where they choose the content they wish to share. This type is
      refered to as "User Choice Permission".</p>


      <table class="simple">
        <thead>
          <tr>
            <th>Shared</th>

            <th>Permission</th>
          </tr>
        </thead>


        <tbody>
          <!--
          <tr> <td> canvas </td> <td> Some canvas will allow getImageData to
            access the pixels in the canvas. These types of canvas do not need
            any additional permission. Other canvas requires Application
            Permission. In addition, if a specific canvasId is not provided,
            there also needs to be a User Choice Permission to select the
            tab.</td> </tr>
            -->


          <tr>
            <td>browser</td>

            <td>Requires Application Permission to use this and if a specific
            tabId is not provided, there also needs to be a User Choice
            Permission to select the tab.</td>
          </tr>
          <!--
          <tr> <td> window </td> <td> Requires an User Choice Permission to
            select the window. The window can not be a window of the same
            browser doing the sharing. </td> </tr>
            -->


          <tr>
            <td>application</td>

            <td>Requires an User Choice Permission to select the application.
            The application can not be the same browser doing the sharing.</td>
          </tr>


          <tr>
            <td>screen</td>

            <td>Requires Application Permission to use this as well as the User
            Choice Permission to select the screen to share for multiscreen
            system and to allow sharing to start for single screen systems. The
            browser window must be masked in this case. [[OPEN ISSUE:
            Consistent with above, but is it OK]]</td>
          </tr>
          <!--
          <tr> <td> area </td> <td> Same as screen.  </td> </tr>
          -->
        </tbody>
      </table>


      <p>When content is being shared, it is important to consider what user
      interface can be provided to remind the user which content is being
      shared. In addition, there MUST be a way for the user to stop sharing.
      Implementations can handle this in a simular way to how they handle
      sharing of a camera or microphone.</p>
    </section>
  </section>


  <section class="informative">
    <h2>Implementation Suggestions</h2>


    <div class="practice">
      <span id="resource-reservation" class="practicelab">Resource
      reservation</span>

      <p class="practicedesc">The user agent is encouraged to reserve resources
      when it has determined that a given call to <a href=
      "#dom-navigator-getusermedia">getUserMedia()</a> will succeed. It is
      preferable to reserve the resource prior to invoking the success callback
      provided by the web page. Subsequent calls to <a href=
      "#dom-navigator-getusermedia">getUserMedia()</a> (in this page or any
      other) should treat the resource that was previously allocated, as well
      as resources held by other applications, as busy. Resources marked as
      busy should not be provided as sources to the current web page, unless
      specified by the user. Optionally, the user agent may choose to provide a
      stream sourced from a busy source but only to a page whose origin matches
      the owner of the original stream that is keeping the source busy.</p>


      <p class="practicedesc">This document recommends that in the permission
      grant dialog or device selection interace (if one is present), the user
      be allowed to select any available hardware as a source for the stream
      requested by the page (provided the resource is able to fulfill mandatory
      constraints, if any were specified), in addition to the ability to
      substitute a video or audio source with local files and other media. A
      file picker may be used to provide this functionality to the user.</p>


      <p class="practicedesc">This document also recommends that the user be
      shown all resources that are currently busy as a result of prior calls to
      <a href="#dom-navigator-getusermedia">getUserMedia()</a> (in this page or
      any other page that is still alive) and be allowed to terminate that
      stream and utilize the resource for the current page instead. If possible
      in the current operating environment, it is also suggested that resources
      currently held by other applications be presented and treated in the same
      manner. If the user chooses this option, the track corresponding to the
      resource that was provided to the page whose stream was affected must be
      removed.</p>
    </div>


    <div class="practice">
      <span id="handling-devices" class="practicelab">Handling multiple
      devices</span>

      <p class="practicedesc">A <a>MediaStream</a> may contain more than one
      video and audio track. This makes it possible to include video from two
      or more webcams in a single stream object, for example. However, the
      current API does not allow a page to express a need for multiple video
      streams from independent sources.</p>


      <p class="practicedesc">It is recommended for multiple calls to <a href=
      "#dom-navigator-getusermedia">getUserMedia()</a> from the same page be
      allowed as a way for pages to request multiple, discrete, video or audio
      streams.</p>


      <p class="practicedesc">A single call to <a href=
      "#dom-navigator-getusermedia">getUserMedia()</a> will always return a
      stream with either zero or one audio tracks, and either zero or one video
      tracks. If a script calls <a href=
      "#dom-navigator-getusermedia">getUserMedia()</a> multiple times before
      reaching a stable state, this document advises the UI designer that the
      permission dialogs should be merged, so that the user can give permission
      for the use of multiple cameras and/or media sources in one dialog
      interaction. The constraints on each getUserMedia call can be used to
      decide which stream gets which media sources.</p>
    </div>
  </section>


  <section>
    <h2>Change Log</h2>


    <p>This section will be removed before publication.</p>


    <h2>Changes since TBD, 2014</h2>
  </section>


  <section class="appendix">
    <h2>Acknowledgements</h2>


    <p>The editors wish to thank ....</p>
  </section>
</body>
</html>
